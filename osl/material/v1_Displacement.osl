/*
 *  Copyright 2018 Laika, LLC. Authored by Mitch Prater.
 *
 *  Licensed under the Apache License Version 2.0 http://apache.org/licenses/LICENSE-2.0,
 *  or the MIT license http://opensource.org/licenses/MIT, at your option.
 *
 *  This program may not be copied, modified, or distributed except according to those terms.
 */
/*
    Duplicate material displacement only.
 */
#include "ikaConstants.h"
#include "material/v1_Displacement.h"
#include "material/v1_PxrSurface.h"

shader v1_Displacement
[[
    int rfm_nodeid = 1233956,
    string rfm_classification = "rendernode/RenderMan/pattern/Laika/material",
    string URL = "https://app.laika.com/intranet/vfx/shading/film6_shading_nodes/material",
    string help = 
        "Creates a <strong>Material</strong> layer that has only <strong>Displacement.</strong> "
        "<br/><br/>"
        "Note: <strong>Displacements</strong> will affect other <strong>Material</strong> "
        "layer displacements based on their layer order, <strong>Thickness,</strong> "
        "and <strong>Mask</strong> values. "
]]
(
    string Notes = ""
    [[
        int connectable = 0,
        string URL = "https://app.laika.com/intranet/vfx/shading/film6_shading_nodes/material",
        string help = 
            "Creates a <strong>Material</strong> layer that has only <strong>Displacement.</strong> "
            "<br/><br/>"
            "Note: <strong>Displacements</strong> will affect other <strong>Material</strong> "
            "layer displacements based on their layer order, <strong>Thickness,</strong> "
            "and <strong>Mask</strong> values. "
            "<br/><br/>"
    ]],

    /*
     *  The Input Material data set.
     *
     *  This consists of a vstruct parameter, a material struct parameter, and a set
     *  of enable parameters for each response. The material struct and response enable
     *  parameters are members of the vstruct parameter.
     */
    // The vstruct parameter. This is the single material connection point
    // for all the material parameters in the material struct.
    PXRSURFACE_MATERIAL_VSTRUCT( MaterialInput, Material Input,
            The connected <strong>Material Input</strong> layers OVER this one:
            connect a PxrSurface <strong>Material Output</strong> here to
            layer it OVER this material.
            ),

    // The material struct parameter.
    PXRSURFACE_MATERIAL_STRUCT( MaterialInput, MatIn ),

    // The response Enable parameters. These are linked to a vstructmember of the vstruct parameter.
    ALL_ENABLE_PARAMS( MaterialInput, ClearCoat ),
    ALL_ENABLE_PARAMS( MaterialInput, PrimarySpecular ),
    ALL_ENABLE_PARAMS( MaterialInput, SecondarySpecular ),
    RESPONSE_ENABLE_PARAM( MaterialInput, Iridescence ),
    ANISOTROPYDIRECTION_ENABLE_PARAM( MaterialInput, Iridescence ),
    RESPONSE_ENABLE_PARAM( MaterialInput, Fuzz ),
    SHADINGNORMAL_ENABLE_PARAM( MaterialInput, Fuzz ),
    RESPONSE_ENABLE_PARAM( MaterialInput, Diffuse ),
    SHADINGNORMAL_ENABLE_PARAM( MaterialInput, Diffuse ),
    RESPONSE_ENABLE_PARAM( MaterialInput, Scatter ),
    RESPONSE_ENABLE_PARAM( MaterialInput, Subsurface ),
    RESPONSE_ENABLE_PARAM( MaterialInput, Glass ),
    ANISOTROPYDIRECTION_ENABLE_PARAM( MaterialInput, Glass ),
    RESPONSE_ENABLE_PARAM( MaterialInput, Glow ),

    /*
     *  This material's user interface parameters.
     */
    int Enable = 1
    [[
        int connectable = 0,
        string label = "Enable",
        string widget = "checkBox",
        string help =
            "Turns the computation of this Material On/Off. "
            "When disabled, this material will not be included in any layered set of materials: its "
            "<strong>Material Input</strong> will be copied directly to its <strong>Material Output</strong>. "
    ]],

    float Mask = 1.0
    [[
        string label = "Mask",
        int slider = 1, float slidermin = 0.0, float slidermax = 1.0,
        string help =
            "This material <strong>Mask</strong> (a.k.a. Opacity, Alpha, Matte, Presence, etc.) "
            "determines the distribution of this material layer: where it is versus where it isn't. "
            "Specifically, it controls the blend between this material and the material "
            "composited UNDER it. "
            "<br/><br/>"
            "Can optionally be used in the generation of a <strong>Pattern Ramp</strong> based on "
            "the <strong>Displacement</strong> to produce a more physically plausible transition "
            "between this and other material layers. "
            "<br/><br/>"
            "Note: when <strong>Pattern Ramp</strong> is <em>On</em>, <strong>Mask</strong> "
            "must contain a broad, smooth ramp from 0 to 1 - not a hard edged transition. "
            "If you're using a painted texture with hard edges, use the texture <strong>Blur</strong> "
            "control to turn them into a smooth ramp for use with this functionality. "
            "Or better still, blur the texture itself before using it. "
    ]],

    //
    //  Displacement parameters start here.
    //
    float Displacement_Thickness = 0.0
    [[
        string page = "Displacement",
        string label = "Thickness",
        int slider = 1, float slidermin = 0.0, float slidermax = 1.0,
        string help =
            "<strong>Thickness</strong> determines the degree to which this material will "
            "cover over the displacement of the underlying material (the one connected to "
            "<strong>Material Output</strong>). "
            "<br/><br/>"
            "When 0, this material has no thickness, so it will be applied directly "
            "to, and exactly follow, the underlying material's displaced surface. "
            "<br/><br/>"
            "When 1, this material is completely 'thick', so it will be applied to the underlying "
            "material's smooth <strong>Covering Height</strong> surface. "
    ]],

    float Displacement_BumpPercent = 1.0
    [[
        string page = "Displacement",
        string label = "Bump Percent",
        int slider = 1, float slidermin = 0.0, float slidermax = 2.0,
        string help =
            "How much of the displaced surface normal is used in shading? "
            "<br/><br/>"
            "Values greater than 1 <em>accentuate</em> the shading effects of the displacement. "
            "<br/><br/>"
            "Values less than 1 <em>diminish</em> the shading effects of any displacement. "
            "The result of this can be used as a simple substitute for subsurface scattering effects. "
            "<br/><br/>"
            "Note: any time the shading normal doesn't match the geometry's normal "
            "(<strong>Bump Percent</strong> â‰  1), there is the possibility "
            "of artifacts in the shaded result - particularly when <strong>Bump Percent</strong> > 1. "
            "You've been warned. "
    ]],

    float Displacement_CoveringHeight = 0.0
    [[
        string page = "Displacement",
        string label = "Covering Height",
        int slider = 1, float slidermin = 0.0, float slidermax = 5.0, float slidercenter = 0.5,
        string help =
            "Sets the height (in <strong>Mag Space</strong>) of a uniformly displaced surface that's "
            "produced when this material is completely covered by an overlying material: i.e. when that "
            "material's <strong>Thickness</strong> = 1. "
            "<br/><br/>"
            "It is the height of a level surface that's intended to cover the peaks of this "
            "material's displacement. "
            "A good starting number is (0.25 + 0.5*Position)*(Magnitude), or, assuming Position=0, "
            "0.25*Magnitude. "
            "<br/><br/>"
            "If <strong>Covering Height</strong> is left at 0, the original geometric surface is used. "
    ]],

    string Displacement_MagSpace = "world"
    [[
        int connectable = 0,
        string page = "Displacement",
        string label = "Mag Space",
        string widget = "mapper",
        string options = "common:common|object:object|shader:shader|world:world",
        string help =
            "The coordinate system in which the Displacement <strong>Covering Height</strong> "
            "and Float and Vector <strong>Magnitude</strong> units are specified. "
    ]],

    float Displacement_MagScale = 1.0
    [[
        string page = "Displacement",
        string label = "Mag Scale",
        int slider = 1, float slidermin = 0.0, float slidermax = 2.0,
        string help =
            "An overall scale applied to <em>all</em> the Input Float "
            "and Vector <strong>Magnitude</strong> values used by this material. "
    ]],

    // Float displacements.
    DISPLACE_FLOAT_UI_DECLARE(0),
    DISPLACE_FLOAT_UI_DECLARE(1),
    DISPLACE_FLOAT_UI_DECLARE(2),
    DISPLACE_FLOAT_UI_DECLARE(3),
    DISPLACE_FLOAT_UI_DECLARE(4),

    // Vector displacements.
    string Displacement_Vector_DirSpace = "magspace"
    [[
        int connectable = 0,
        string page = "Displacement.Vector",
        string label = "Dir Space",
        string widget = "mapper",
        string options =
            "Mag Space Value:magspace"
            "|common:common"
            "|object:object"
            "|shader:shader"
            "|world:world",
        string help =
            "The coordinate system in which the Vector <strong>Input</strong> <em>Directions</em> are specified. "
            "<em>common</em> is the default space used by vectors or normals such as "
            "<strong>N</strong>, <strong>V</strong>, or <strong>T</strong> (from ris/data/ShadingVars). "
            "<br/><br/>"
            "Note: it is assumed the <strong>Input</strong> vectors have a maximum length of 1. "
            "<strong>Mag Space</strong> and <strong>Magnitude</strong> therefore determine their "
            "amount of displacement. "
            "<br/>"
            "<strong>Dir Space</strong> however, specifies their orientation (direction) space: vector "
            "direction and magnitude are separate characteristics. "
    ]],

    DISPLACE_VECTOR_UI_DECLARE(0),
    DISPLACE_VECTOR_UI_DECLARE(1),
    DISPLACE_VECTOR_UI_DECLARE(2),
    DISPLACE_VECTOR_UI_DECLARE(3),
    DISPLACE_VECTOR_UI_DECLARE(4),

    //
    //  Pattern Ramp parameters start here.
    //
    int PatternRamp_Enable = 0
    [[
        int connectable = 0,
        string page = "Pattern Ramp",
        string label = "Enable",
        string widget = "checkBox",
        string help =
            "When <em>On</em>, use this material's <strong>Displacement</strong> to generate "
            "a pattern ramp and apply it to the material <strong>Mask</strong>. "
            "This can produce a more physically plausible transition from one material to the next. "
            "<br/><br/>"
            "Note: when this is <em>On</em>, the material <strong>Mask</strong> "
            "must contain a broad, smooth ramp from 0 to 1 - not a hard edged transition. "
            "If you're using a painted texture with hard edges, use the texture <strong>Blur</strong> "
            "control to turn them into a smooth ramp for use with this functionality. "
            "Or better still, blur the texture itself before using it. "
    ]],

    float PatternRamp_DispSoftness = 0.25
    [[
        string page = "Pattern Ramp",
        string label = "Disp Softness",
        int slider = 1, float slidermin = 0.0, float slidermax = 1.0,
        string help =
            "Adjusts the <strong>Pattern Ramp</strong> edge hardness/softness used for displacement: "
            "<br/><br/>"
            "<strong>0</strong> produces a hard edge in the mask pattern. "
            "<br/>"
            "<strong>1</strong> produces soft edges in the mask pattern. "
            "<br/><br/>"
            "Note: you can use the <strong>dispMask</strong> output to see the generated mask pattern. "
    ]],

    float PatternRamp_LowerCutoff = 0.0
    [[
        string page = "Pattern Ramp",
        string label = "Lower Cutoff",
        int slider = 1, float slidermin = -0.1, float slidermax = 0.5,
        string help =
            "This material's <strong>Displacement</strong> is first normalized to approximately "
            "a 0-1 ranged value. It's this normalized displacement value that is used to generate "
            "the mask's pattern ramp. The normalization can only be approximate however, so the "
            "<strong>Lower Cutoff</strong> and <strong>Upper Cutoff</strong> values are used to "
            "ensure the pattern ramp goes fully to 0 and 1 by clipping the normalized displacement "
            "if necessary. "
    ]],

    float PatternRamp_UpperCutoff = 1.0
    [[
        string page = "Pattern Ramp",
        string label = "Upper Cutoff",
        int slider = 1, float slidermin = 0.5, float slidermax = 1.1,
        string help =
            "This material's <strong>Displacement</strong> is first normalized to approximately "
            "a 0-1 ranged value. It's this normalized displacement value that is used to generate "
            "pattern ramp. The normalization can only be approximate however, so the "
            "<strong>Lower Cutoff</strong> and <strong>Upper Cutoff</strong> values are used to "
            "ensure the pattern ramp goes fully to 0 and 1 by clipping the normalized displacement "
            "if necessary. "
    ]],

    // Utility socket.
    int Socket = 0
    [[
        string help =
            "Connect a shading node's <strong>Plug</strong> output here in order to execute that node and "
            "any shading tree connected to it. "
    ]],

    /*
     *  The Output Material data set.
     * 
     *  This consists of a vstruct parameter, a material struct parameter, and a set
     *  of enable parameters for each response. The material struct and response enable
     *  parameters are members of the vstruct parameter.
     */
    output PXRSURFACE_MATERIAL_VSTRUCT( MaterialOutput, Material Output,
            Connect this to a PxrSurface Material shader's <strong>Material Input</strong>
            to layer this OVER it.
            <br/><br/>
            If this is the last Material in the layer chain connect this to a
            <strong>PxrSurface_Material</strong> node.
            ),

    // The struct parameter.
    output PXRSURFACE_MATERIAL_STRUCT( MaterialOutput, MatOut ),

    // Set the output vstruct Enable parameters based on the input Enable value and user parameter settings.
    SET_ALL_ENABLE_PARAMS( MaterialOutput, MaterialInput, ClearCoat ),
    SET_ALL_ENABLE_PARAMS( MaterialOutput, MaterialInput, PrimarySpecular ),
    SET_ALL_ENABLE_PARAMS( MaterialOutput, MaterialInput, SecondarySpecular ),
    SET_RESPONSE_ENABLE_PARAM( MaterialOutput, MaterialInput, Iridescence ),
    SET_ANISOTROPYDIRECTION_ENABLE_PARAM( MaterialOutput, MaterialInput, Iridescence ),
    SET_RESPONSE_ENABLE_PARAM( MaterialOutput, MaterialInput, Fuzz ),
    SET_SHADINGNORMAL_ENABLE_PARAM( MaterialOutput, MaterialInput, Fuzz ),
    SET_RESPONSE_ENABLE_PARAM( MaterialOutput, MaterialInput, Diffuse ),
    SET_SHADINGNORMAL_ENABLE_PARAM( MaterialOutput, MaterialInput, Diffuse ),
    SET_RESPONSE_ENABLE_PARAM( MaterialOutput, MaterialInput, Scatter ),
    SET_RESPONSE_ENABLE_PARAM( MaterialOutput, MaterialInput, Subsurface ),
    SET_RESPONSE_ENABLE_PARAM( MaterialOutput, MaterialInput, Glass ),
    SET_ANISOTROPYDIRECTION_ENABLE_PARAM( MaterialOutput, MaterialInput, Glass ),
    SET_RESPONSE_ENABLE_PARAM( MaterialOutput, MaterialInput, Glow ),

    // This material's masks, as possibly modified by a pattern ramp.
    output float dispMask = 1.0 [[ string widget = "null" ]]
)
/*
 *  Material functionality: Output = Input OVER this.
 */
{
    // Pull on the Socket to make sure it's evaluated.
    MatOut.socket = Socket;

    // Bxdf data is passed through.
    MatOut = MatIn;

    // Short-circuit this material.
    if( Enable != 0 )
    {

    // Initialize this material's mask values.
    dispMask = Mask; // this_dispMask


    //
    //  Displacement.
    //
    // Used by float displacements.
    normal  Nn = normalize(N);
    normal  Nmag = Nn / length( transform( Displacement_MagSpace, Nn ));

    // Used by vector displacements.
    string  dispDirSpace = ( Displacement_Vector_DirSpace != "magspace" ) ?
                Displacement_Vector_DirSpace : Displacement_MagSpace;

    float   dirScale = 1.0 / length(
                transform( Displacement_MagSpace, vector( dispDirSpace, IKA_INVSQRT3, IKA_INVSQRT3, IKA_INVSQRT3 ) )
                );

    // The covering height offset surface vector for this material.
    vector  this_coverV = Nmag*Displacement_CoveringHeight;

    // The deltaP displacement vector for this material.
    vector  this_deltaP = Nmag * (
                        DISPLACE_FLOAT_AMOUNT(0)
                        + DISPLACE_FLOAT_AMOUNT(1)
                        + DISPLACE_FLOAT_AMOUNT(2)
                        + DISPLACE_FLOAT_AMOUNT(3)
                        + DISPLACE_FLOAT_AMOUNT(4)
                        );

    this_deltaP += dirScale * transform( dispDirSpace, "common",
                        DISPLACE_VECTOR_AMOUNT(0)
                        + DISPLACE_VECTOR_AMOUNT(1)
                        + DISPLACE_VECTOR_AMOUNT(2)
                        + DISPLACE_VECTOR_AMOUNT(3)
                        + DISPLACE_VECTOR_AMOUNT(4)
                        );

    // Globally scale the displacement. Displacement_MagScale is unitless.
    this_deltaP *= Displacement_MagScale;

    // Modify the Mask with a patterned ramp?
    if( PatternRamp_Enable == 1 )
    {
        // Determine displacement-based ramp pattern.
        float  this_rampPattern = DISPLACE_FLOAT_PATTERN(0)
                            + DISPLACE_FLOAT_PATTERN(1)
                            + DISPLACE_FLOAT_PATTERN(2)
                            + DISPLACE_FLOAT_PATTERN(3)
                            + DISPLACE_FLOAT_PATTERN(4)
                            ;

        this_rampPattern += DISPLACE_VECTOR_PATTERN(0)
                            + DISPLACE_VECTOR_PATTERN(1)
                            + DISPLACE_VECTOR_PATTERN(2)
                            + DISPLACE_VECTOR_PATTERN(3)
                            + DISPLACE_VECTOR_PATTERN(4)
                            ;

        float  this_rampMag = DISPLACE_FLOAT_MAG(0)
                            + DISPLACE_FLOAT_MAG(1)
                            + DISPLACE_FLOAT_MAG(2)
                            + DISPLACE_FLOAT_MAG(3)
                            + DISPLACE_FLOAT_MAG(4)
                            ;

        this_rampMag += DISPLACE_VECTOR_MAG(0)
                            + DISPLACE_VECTOR_MAG(1)
                            + DISPLACE_VECTOR_MAG(2)
                            + DISPLACE_VECTOR_MAG(3)
                            + DISPLACE_VECTOR_MAG(4)
                            ;

        // Normalize the pattern range.
        if( this_rampMag > 0.0000001 ) this_rampPattern /= this_rampMag;
        else this_rampPattern = 0.5;

        // Generate the pattern ramped masks.
        dispMask = linearstep(
                    Mask - PatternRamp_DispSoftness,
                    Mask + PatternRamp_DispSoftness,
                    // Remap the pattern in preparation for comparing with the Mask value.
                    // The Mask is used to shift the ramp pattern up/down sufficiently to
                    // produce the desired Mask-edgeWidth, Mask+edgeWidth transition.
                    this_rampPattern + mix(
                                        -1.0000001-PatternRamp_LowerCutoff - PatternRamp_DispSoftness,
                                        2.0-PatternRamp_UpperCutoff + PatternRamp_DispSoftness,
                                        Mask
                                        )
                    );
    }

    // Pre-multiply by this mask.
    this_coverV *= dispMask;
    this_deltaP *= dispMask;

    // Note: coverV is not composited. It is only communicated
    // with the immediately overlying material layer.
    MatOut.coverV = this_coverV;

    // Displacement compositing.
    // Note: displacement is NOT Porter-Duff OVER operation composited.
    MatOut.deltaP = MatIn.deltaP + mix(
                                    this_deltaP,
                                    this_coverV,
                                    MatIn.thickness
                                    );

    // Thickness accumulates through all the layers, since layer displacements all accumulate.
    // Any overlying layer's thickness will apply to all layers below it, so always pass on the
    // largest thickness value.
    MatOut.thickness = max( MatIn.thickness, Displacement_Thickness*dispMask );

    // Handle BumpPercent. Just use dispMask - no need for all the bxdfMask controls.
    PARAM_OVER( MatOut, MatIn, Displacement, BumpPercent, dispMask );

    }
}
