/*
 *  Copyright 2018 Laika, LLC. Authored by Mitch Prater.
 *
 *  Licensed under the Apache License Version 2.0 http://apache.org/licenses/LICENSE-2.0,
 *  or the MIT license http://opensource.org/licenses/MIT, at your option.
 *
 *  This program may not be copied, modified, or distributed except according to those terms.
 */
/*
    Material: a single node that combines bxdf and displacement controls.
    Each material node has a Material Input connection which is composited OVER
    this material's parameter settings, and the result is returned in Material Output.
 */
#include "material/Displace.h"
#include "material/PxrSurface.h"

shader PxrSurface
[[
    int rfm_nodeid = 1233883,
    string rfm_classification = "rendernode/RenderMan/pattern/Laika/osl/material",
    string help = 
        "A Material "
        "defines its response to light, its surface displacement, and its presence. "
        "Other materials of the same type can be composited together to produce a single layered material. "
        "The composited result is returned as a <strong>Material Output</strong>. "
        "<br/><br/>"
        "Note: a material that's connected to this one's <strong>Material Input</strong> "
        "is composited OVER this one. "
        "<br/><br/>"
        "<strong>Material Input</strong><br/>"
        "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>↓</strong><br/>"
        "&nbsp;&nbsp;This Material<br/>"
        "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>↓</strong><br/>"
        "<strong>Material Output</strong>"
        "<br/><br/>"
        "The output of the final Material node in the chain is connected to a "
        "<strong>PxrSurface_Controls</strong> node, which produces a "
        "<em>prmanBxdf</em> and a <em>prmanDisplacement</em> output. "
]]
(
    string Notes = ""
    [[
        int connectable = 0,
        string help = 
            "A Material "
            "defines its response to light, its surface displacement, and its presence. "
            "Other materials of the same type can be composited together to produce a single layered material. "
            "The composited result is returned as a <strong>Material Output</strong>. "
            "<br/><br/>"
            "Note: a material that's connected to this one's <strong>Material Input</strong> "
            "is composited OVER this one. "
            "<br/><br/>"
            "<strong>Material Input</strong><br/>"
            "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>↓</strong><br/>"
            "&nbsp;&nbsp;This Material<br/>"
            "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>↓</strong><br/>"
            "<strong>Material Output</strong>"
            "<br/><br/>"
            "The output of the final Material node in the chain is connected to a "
            "<strong>PxrSurface_Controls</strong> node, which produces a "
            "<em>prmanBxdf</em> and a <em>prmanDisplacement</em> output. "
    ]],

    /*
     *  The Input Material data set.
     * 
     *  This consists of a vstruct parameter, a material struct parameter, and a set
     *  of enable parameters for each response. The material struct and response enable
     *  parameters are members of the vstruct parameter.
     */
    int Material_Input = 0
    [[
        string label = "Material Input",
        string readOnly = "true",
        string tag = "Material_PxrSurface",
        string help =
            "The connected <strong>Material Input</strong> layers OVER this one: "
            "connect an osl/material/PxrSurface <strong>Material Output</strong> here to "
            "layer it OVER this material. "
    ]],

    // The struct parameter.
    PXRSURFACE_MATERIAL_STRUCT( Material_Input, Params ),

    // The Enable parameters.
    ALL_ENABLE_PARAMS( Material_Input, clearcoat ),
    ALL_ENABLE_PARAMS( Material_Input, specPrimary ),
    ALL_ENABLE_PARAMS( Material_Input, specSecondary ),
    RESPONSE_ENABLE_PARAM( Material_Input, iridescence ),
    SHADINGTANGENT_ENABLE_PARAM( Material_Input, iridescence ),
    RESPONSE_ENABLE_PARAM( Material_Input, fuzz ),
    SHADINGNORMAL_ENABLE_PARAM( Material_Input, fuzz ),
    RESPONSE_ENABLE_PARAM( Material_Input, diffuse ),
    SHADINGNORMAL_ENABLE_PARAM( Material_Input, diffuse ),
    RESPONSE_ENABLE_PARAM( Material_Input, scatter ),
    RESPONSE_ENABLE_PARAM( Material_Input, subsurface ),
    RESPONSE_ENABLE_PARAM( Material_Input, glass ),
    SHADINGTANGENT_ENABLE_PARAM( Material_Input, glass ),
    RESPONSE_ENABLE_PARAM( Material_Input, glow ),

    /*
     *  This material's user interface parameters.
     */
    int Enable = 1
    [[
        int connectable = 0,
        string label = "Enable",
        string widget = "checkBox",
        string help =
            "Turns the computation of this Material On/Off. "
            "When disabled, this material will not be included in any layered set of materials: its "
            "<strong>Material Input</strong> will be copied directly to its <strong>Material Output</strong>. "
    ]],

    float Mask = 1.0
    [[
        string label = "Mask",
        int slider = 1, float slidermin = 0.0, float slidermax = 1.0,
        string help =
            "This material <strong>Mask</strong> (a.k.a. Opacity, Alpha, Matte, Presence, etc.) "
            "determines the distribution of this material layer: where it is versus where it isn't. "
            "Can optionally be used in the generation of a <strong>Pattern Ramp</strong> based on "
            "the <strong>Displacement</strong> to produce a more physically plausible transition "
            "between this and other material layers. "
            "<br/><br/>"
            "Specifically, it controls the blend between this material and the material "
            "composited UNDER it (the one connected to this one's <strong>Material Output</strong>). "
    ]],

    int EnablePatternRamp = 0
    [[
        int connectable = 0,
        string page = "Pattern Ramp",
        string label = "Enable",
        string widget = "checkBox",
        string help =
            "When <em>On</em>, use this material's <strong>Displacement</strong> to generate "
            "a pattern ramp and apply it to the material <strong>Mask</strong>. "
            "This can produce a more physically plausible transition from one material to the next. "
            "<br/><br/>"
            "Note: when this is <em>On</em>, the material <strong>Mask</strong> "
            "should contain a broad, smooth ramp from 0 to 1 - not a hard edged transition. "
            "If you're using a painted texture with hard edges, use the texture <strong>Blur</strong> "
            "control to turn them into a smooth ramp for use with this functionality. "
            "Or better still, blur the texture itself before using it. "
    ]],

    float BxdfTransition = 0.0
    [[
        string page = "Pattern Ramp",
        string label = "Bxdf Transition",
        int slider = 1, float slidermin = -1.0, float slidermax = 1.0,
        string help =
            "Controls the location of the <strong>Pattern Ramp</strong> transition used for "
            "surface responses by shifting it higher up or lower down on the displacement: "
            "<br/><br/>"
            "<strong>Negative</strong> values will erode this material. "
            "<br/><br/>"
            "<strong>0.0</strong> leaves the transition at the center of mask pattern. "
            "<br/><br/>"
            "<strong>Positive</strong> values will grow this material. "
            "<br/><br/>"
            "Note: you can use the <strong>bxdfMask</strong> output to see the generated mask pattern. "
    ]],

    float BxdfWidth = 0.05
    [[
        string page = "Pattern Ramp",
        string label = "Bxdf Softness",
        int slider = 1, float slidermin = 0.0, float slidermax = 1.0,
        string help =
            "Adjusts the <strong>Pattern Ramp</strong> edge hardness/softness used for the surface responses: "
            "<br/><br/>"
            "<strong>0</strong> produces a hard edge in the mask pattern. "
            "<br/>"
            "<strong>1</strong> produces soft edges in the mask pattern. "
            "<br/><br/>"
            "Note: you can use the <strong>bxdfMask</strong> output to see the generated mask pattern. "
    ]],

    float DispWidth = 0.25
    [[
        string page = "Pattern Ramp",
        string label = "Disp Softness",
        int slider = 1, float slidermin = 0.0, float slidermax = 1.0,
        string help =
            "Adjusts the <strong>Pattern Ramp</strong> edge hardness/softness used for displacement: "
            "<br/><br/>"
            "<strong>0</strong> produces a hard edge in the mask pattern. "
            "<br/>"
            "<strong>1</strong> produces soft edges in the mask pattern. "
            "<br/><br/>"
            "Note: you can use the <strong>dispMask</strong> output to see the generated mask pattern. "
    ]],

    float LowerCutoff = 0.0
    [[
        string page = "Pattern Ramp",
        string label = "Lower Cutoff",
        int slider = 1, float slidermin = -0.1, float slidermax = 0.5,
        string help =
            "This material's <strong>Displacement</strong> is first normalized to approximately "
            "a 0-1 ranged value. It's this normalized displacement value that is used to generate "
            "the mask's pattern ramp. The normalization can only be approximate however, so the "
            "<strong>Lower Cutoff</strong> and <strong>Upper Cutoff</strong> values are used to "
            "ensure the pattern ramp goes fully to 0 and 1 by clipping the normalized displacement "
            "if necessary. "
    ]],

    float UpperCutoff = 1.0
    [[
        string page = "Pattern Ramp",
        string label = "Upper Cutoff",
        int slider = 1, float slidermin = 0.5, float slidermax = 1.1,
        string help =
            "This material's <strong>Displacement</strong> is first normalized to approximately "
            "a 0-1 ranged value. It's this normalized displacement value that is used to generate "
            "pattern ramp. The normalization can only be approximate however, so the "
            "<strong>Lower Cutoff</strong> and <strong>Upper Cutoff</strong> values are used to "
            "ensure the pattern ramp goes fully to 0 and 1 by clipping the normalized displacement "
            "if necessary. "
    ]],

    //
    //  Displacement parameters start here.
    //
    float Thickness = 0.0
    [[
        string page = "Displacement",
        string label = "Thickness",
        int slider = 1, float slidermin = 0.0, float slidermax = 1.0,
        string help =
            "<strong>Thickness</strong> determines the degree to which this material will "
            "cover over the displacement of the underlying material (the one connected to "
            "<strong>Material Output</strong>). "
            "<br/><br/>"
            "When 0, this material has no thickness, so it will be applied directly "
            "to, and exactly follow, the underlying material's displaced surface. "
            "<br/><br/>"
            "When 1, this material is completely 'thick', so it will be applied to the underlying "
            "material's smooth <strong>Covering Height</strong> surface. "
    ]],

    float BumpPercent = 1.0
    [[
        string page = "Displacement",
        string label = "Bump Percent",
        int slider = 1, float slidermin = 0.0, float slidermax = 2.0,
        string help =
            "How much of the displaced surface normal is used in shading? "
            "<br/><br/>"
            "Values greater than 1 <em>accentuate</em> the shading effects of the displacement. "
            "<br/><br/>"
            "Values less than 1 <em>diminish</em> the shading effects of any displacement. "
            "The result of this can be used as a simple substitute for subsurface scattering effects. "
            "<br/><br/>"
            "Note: any time the shading normal doesn't match the geometry's normal "
            "(<strong>Bump Percent</strong> ≠ 1), there is the possibility "
            "of artifacts in the shaded result - particularly when <strong>Bump Percent</strong> > 1. "
            "You've been warned. "
    ]],

    float CoveringHeight = 0.0
    [[
        string page = "Displacement",
        string label = "Covering Height",
        int slider = 1, float slidermin = 0.0, float slidermax = 5.0, float slidercenter = 0.5,
        string help =
            "Sets the height (in <strong>Mag Space</strong>) of a uniformly displaced surface that's "
            "produced when this material is completely covered by an overlying material: i.e. when that "
            "material's <strong>Thickness</strong> = 1. "
            "<br/><br/>"
            "It is the height of a level surface that's intended to cover the peaks of this "
            "material's displacement. "
            "A good starting number is (0.25 + 0.5*Position)*(Magnitude), or, assuming Position=0, "
            "0.25*Magnitude. "
            "<br/><br/>"
            "If <strong>Covering Height</strong> is left at 0, the original geometric surface is used. "
    ]],

    string DispMagSpace = "world"
    [[
        int connectable = 0,
        string page = "Displacement",
        string label = "Mag Space",
        string widget = "mapper",
        string options = "common:common|object:object|shader:shader|world:world",
        string help =
            "The coordinate system in which the Displacement <strong>Covering Height</strong> "
            "and Float and Vector <strong>Magnitude</strong> units are specified. "
    ]],

    float DispMagScale = 1.0
    [[
        string page = "Displacement",
        string label = "Mag Scale",
        int slider = 1, float slidermin = 0.0, float slidermax = 2.0,
        string help =
            "An overall scale applied to <em>all</em> the Input Float "
            "and Vector <strong>Magnitude</strong> values used by this material. "
    ]],

    // Float displacements.
    DISPLACE_FLOAT_UI_DECLARE(0),
    DISPLACE_FLOAT_UI_DECLARE(1),
    DISPLACE_FLOAT_UI_DECLARE(2),
    DISPLACE_FLOAT_UI_DECLARE(3),
    DISPLACE_FLOAT_UI_DECLARE(4),

    // Vector displacements.
    string DispDirSpace = "magspace"
    [[
        int connectable = 0,
        string page = "Displacement.Vector",
        string label = "Dir Space",
        string widget = "mapper",
        string options =
            "Mag Space Value:magspace"
            "|common:common"
            "|object:object"
            "|shader:shader"
            "|world:world",
        string help =
            "The coordinate system in which the Vector <strong>Input</strong> <em>Directions</em> are specified. "
            "<em>common</em> is the default space used by vectors or normals such as "
            "<strong>N</strong>, <strong>V</strong>, or <strong>T</strong> (from ris/data/ShadingVars). "
            "<br/><br/>"
            "Note: it is assumed the <strong>Input</strong> vectors have a maximum length of 1. "
            "<strong>Mag Space</strong> and <strong>Magnitude</strong> therefore determine their "
            "amount of displacement. "
            "<br/>"
            "<strong>Dir Space</strong> however, specifies their orientation (direction) space: vector "
            "direction and magnitude are separate characteristics. "
    ]],

    DISPLACE_VECTOR_UI_DECLARE(0),
    DISPLACE_VECTOR_UI_DECLARE(1),
    DISPLACE_VECTOR_UI_DECLARE(2),
    DISPLACE_VECTOR_UI_DECLARE(3),
    DISPLACE_VECTOR_UI_DECLARE(4),

    //
    // Bxdf parameters start here.
    //
    normal globalShadingNormal = normal( 0.0 )
    [[
        string page = "Global",
        string label = "Shading Normal",
        string help =
            "An alternate shading normal to use for all responses. "
            "If an individual response specifies its own shading normal values, "
            "they will override these settings. "
    ]],

    float globalUseShadingNormal = 1.0
    [[
        string page = "Global",
        string label = "Use Shading Normal",
        int slider = 1, float slidermin = 0.0, float slidermax = 1.0,
        string help =
            "How much of the connected <strong>Shading Normal</strong> is used? "
            "This is a mix between the regular (potentially displaced) shading normal <strong>N</strong>, "
            "and the connected <strong>Shading Normal</strong> value. "
            "<br/><br/>"
            "Note: this has no effect if the <strong>Shading Normal</strong> is unconnected. "
    ]],

    color globalShadowColor = color( 0.0 )
    [[
        string page = "Global",
        string label = "Shadow Color",
        string help =
            "Sets the color of the shadows cast by this material. "
    ]],

    // Clearcoat response.
    CLEARCOAT_UI_DECLARE( Clear Coat, clearcoat,
            <strong>Clear Coat</strong> represents a clear specular layer applied over all the other 
            responses. It can be truly clear. Or it can optionally absorb colored light from the layers 
            below it to tint the overall response.
            , clearcoatRoughnessUIDefault ),

    // Primary specular response.
    SPECULAR_UI_DECLARE( Primary Specular, specPrimary, 
            <strong>Primary Specular</strong> is the first of two 'standard' specular responses.
            It is capable of producing a broad range of response types from artistic
            to physically based and dielectric to metallic.
            , specPrimaryRoughnessUIDefault ),

    // Secondary specular response.
    SPECULAR_UI_DECLARE( Secondary Specular, specSecondary, 
            <strong>Secondary Specular</strong> is the second of two 'standard' specular responses.
            It is capable of producing a broad range of response types from artistic
            to physically based and dielectric to metallic.
            , specSecondaryRoughnessUIDefault ),

    // Iridescence response.
    IRIDESCENCE_UI_DECLARE( Iridescence, iridescence,
            <strong>Iridescence</strong> is a special type of specular response.
            It produces the effects of thin-film interference and can be controlled
            using Artistic or Physically based controls.
            ),

    // Fuzz response.
    FUZZ_UI_DECLARE( Fuzz, fuzz,
            <strong>Fuzz</strong> produces scattering of the illumination in
            a boundry layer on the surface. It is implemented as a Marschner
            hair primary reflection response (R component) where the hair fibers
            are oriented in the direction of the shading normal.
            ),

    // Diffuse response.
    DIFFUSE_UI_DECLARE( Diffuse, diffuse,
            <strong>Diffuse</strong> uses an Oren-Nayar response model employing
            a Roughness parameter to control the deviation of micro-facet normals.
            ),

    // Scatter response.
    SCATTER_UI_DECLARE( Scatter, scatter,
            <strong>Scatter</strong> produces (single) scattering through the interior
            of an object. It has many controls for altering the physical and artistic
            characteristics of the response.
            Its main feature is the ability to alter the directionality of the scattering
            from forward to backward to isotropic.
            ),

    // Subsurface response.
    SUBSURFACE_UI_DECLARE( Subsurface, subsurface,
            <strong>Subsurface</strong> produces multiple scattering through the interior
            of an object. It has many controls for altering the physical and artistic
            characteristics of the response.
            ),

    // Scatter & Subsurface controls.
    color ssIlluminationTint = color( 1.0 )
    [[
        string page = "Scatter and Subsurface",
        string label = "Illumination Tint",
        string help =
            "Tints the incoming illumination prior to being used in the "
            "<strong>Scatter</strong> and <strong>Subsurface</strong> response computations. "
            "In light linear space. "
    ]],

    float ssRoughness = 0.0
    [[
        string page = "Scatter and Subsurface",
        string label = "Roughness",
        int slider = 1, float slidermin = 0.0, float slidermax = 1.0,
        string help =
            "Controls the diffuse micro-facet surface roughness used in the "
            "<strong>Scatter</strong> and <strong>Subsurface</strong> response computations. "
            "Increasing <strong>Roughness</strong> causes the rays penetrating into "
            "the material to have an increasingly broader range of directions than lower "
            "<strong>Roughness</strong> values. This tends to slightly darken the overall response, "
            "as the light is more widely dispersed prior to entering the material. "
    ]],

    // Glass response.
    GLASS_UI_DECLARE( Glass, glass,
            <strong>Glass</strong> produces a physically-based glass that
            includes <strong>Reflection</strong> and <strong>Refraction</strong>.
            It has many controls for altering the physical properties of the glass
            including its interior.
            ),
    

    // Glow response.
    EGC_UI_DECLARE( Glow, glow,
            <strong>Glow</strong> can make an object appear to emit light.
            <br/><br/>
            Note: this is not an efficient way to illuminate a scene and would require
            indirect bounces to be at least 2 to be effective. This should instead be
            used simply as a shading effect and not for actual lighting.
            ),

    // Utility socket.
    int Socket = 0
    [[
        string help =
            "Connect a shading node's <strong>Plug</strong> output here in order to execute that node and "
            "any shading tree connected to it. "
    ]],


    /*
     *  The Output Material data set.
     * 
     *  This consists of a vstruct parameter, a material struct parameter, and a set
     *  of enable parameters for each response. The material struct and response enable
     *  parameters are members of the vstruct parameter.
     */
    output int Material_Output = 0
    [[
        string label = "Material Output",
        string tag = "Material_PxrSurface",
        string widget = "null",
        string help =
            "Connect this to a PxrSurface Material shader's <strong>Material Input</strong> "
            "to layer this OVER it. "
            "<br/><br/>"
            "If this is the last Material in the layer chain, connect this to a "
            "<strong>PxrSurface_Material</strong> node. "
    ]],

    // The struct parameter.
    output PXRSURFACE_MATERIAL_STRUCT( Material_Output, Params ),

    // Set the vstruct Enable parameters based on the input Enable and user parameter settings.
    output ALL_ENABLE_PARAMS_SET( Material_Output, Material_Input, clearcoat ),
    output ALL_ENABLE_PARAMS_SET( Material_Output, Material_Input, specPrimary ),
    output ALL_ENABLE_PARAMS_SET( Material_Output, Material_Input, specSecondary ),
    output RESPONSE_ENABLE_PARAM_SET( Material_Output, Material_Input, iridescence ),
    output SHADINGTANGENT_ENABLE_PARAM_SET( Material_Output, Material_Input, iridescence ),
    output RESPONSE_ENABLE_PARAM_SET( Material_Output, Material_Input, fuzz ),
    output SHADINGNORMAL_ENABLE_PARAM_SET( Material_Output, Material_Input, fuzz ),
    output RESPONSE_ENABLE_PARAM_SET( Material_Output, Material_Input, diffuse ),
    output SHADINGNORMAL_ENABLE_PARAM_SET( Material_Output, Material_Input, diffuse ),
    output RESPONSE_ENABLE_PARAM_SET( Material_Output, Material_Input, scatter ),
    output RESPONSE_ENABLE_PARAM_SET( Material_Output, Material_Input, subsurface ),
    output RESPONSE_ENABLE_PARAM_SET( Material_Output, Material_Input, glass ),
    output SHADINGTANGENT_ENABLE_PARAM_SET( Material_Output, Material_Input, glass ),
    output RESPONSE_ENABLE_PARAM_SET( Material_Output, Material_Input, glow ),

    // This material's masks, as possibly modified by a pattern ramp.
    output float bxdfMask = 1.0 [[ string widget = "null" ]],
    output float dispMask = 1.0 [[ string widget = "null" ]]
)
/*
 *  Material functionality: Output = Input OVER this.
 */
{
    // Pull on the Socket to make sure it's evaluated.
    Material_Output_Params.socket = Socket;

    // Short-circuit this material.
    if( Enable == 0 )
    {
        Material_Output_Params = Material_Input_Params;
    }

    // Note: using a return statement in the if case above breaks functionality,
    // so must use this else clause.
    // My guess is the osl optimizer is mucking with the proper behavior.
    else
    {

    // Initialize this material's mask values.
    bxdfMask = Mask; // this_bxdfMask
    dispMask = Mask; // this_dispMask

    //
    //  Displacement.
    //
    // Used by float displacements.
    normal  Nn = normalize(N);
    normal  Nmag = Nn / length( transform( DispMagSpace, Nn ));

    // Used by vector displacements.
    string  dispDirSpace = ( DispDirSpace != "magspace" ) ? DispDirSpace : DispMagSpace;
    float   dirScale = 1.0 / length(
                transform( DispMagSpace, vector( dispDirSpace, 0.577350269189626, 0.577350269189626, 0.577350269189626 ))
                );

    // The covering height offset surface vector for this material.
    vector  this_coverV = Nmag*CoveringHeight;

    // The deltaP displacement vector for this material.
    vector  this_deltaP = Nmag * (
                        DISPLACE_FLOAT_AMOUNT(0)
                        + DISPLACE_FLOAT_AMOUNT(1)
                        + DISPLACE_FLOAT_AMOUNT(2)
                        + DISPLACE_FLOAT_AMOUNT(3)
                        + DISPLACE_FLOAT_AMOUNT(4)
                        );

    this_deltaP += dirScale * transform( dispDirSpace, "common",
                        DISPLACE_VECTOR_AMOUNT(0)
                        + DISPLACE_VECTOR_AMOUNT(1)
                        + DISPLACE_VECTOR_AMOUNT(2)
                        + DISPLACE_VECTOR_AMOUNT(3)
                        + DISPLACE_VECTOR_AMOUNT(4)
                        );


    // Modify the Mask with a patterned ramp?
    if( EnablePatternRamp == 1 )
    {
        // Determine displacement-based ramp pattern.
        float  this_rampPattern = DISPLACE_FLOAT_PATTERN(0)
                            + DISPLACE_FLOAT_PATTERN(1)
                            + DISPLACE_FLOAT_PATTERN(2)
                            + DISPLACE_FLOAT_PATTERN(3)
                            + DISPLACE_FLOAT_PATTERN(4)
                            ;

        this_rampPattern += DISPLACE_VECTOR_PATTERN(0)
                            + DISPLACE_VECTOR_PATTERN(1)
                            + DISPLACE_VECTOR_PATTERN(2)
                            + DISPLACE_VECTOR_PATTERN(3)
                            + DISPLACE_VECTOR_PATTERN(4)
                            ;

        float  this_rampMag = DISPLACE_FLOAT_MAG(0)
                            + DISPLACE_FLOAT_MAG(1)
                            + DISPLACE_FLOAT_MAG(2)
                            + DISPLACE_FLOAT_MAG(3)
                            + DISPLACE_FLOAT_MAG(4)
                            ;

        this_rampMag += DISPLACE_VECTOR_MAG(0)
                            + DISPLACE_VECTOR_MAG(1)
                            + DISPLACE_VECTOR_MAG(2)
                            + DISPLACE_VECTOR_MAG(3)
                            + DISPLACE_VECTOR_MAG(4)
                            ;

        // Normalize the pattern range.
        if( this_rampMag > 0.0000001 ) this_rampPattern /= this_rampMag;
        else this_rampPattern = 0.5;

        // Generate the pattern ramped masks.
        bxdfMask = linearstep(
                    Mask - BxdfWidth,
                    Mask + BxdfWidth,
                    // Remap the pattern in preparation for comparing with the Mask value.
                    // The Mask is used to shift the ramp pattern up/down sufficiently to
                    // produce the desired Mask-edgeWidth, Mask+edgeWidth transition.
                    this_rampPattern + mix(
                                        -1.0000001-LowerCutoff - BxdfWidth,
                                        2.0-UpperCutoff + BxdfWidth,
                                        pow( Mask, pow( 3.0, -BxdfTransition )) // Grow/Erode the Masked area.
                                        )
                    );

        dispMask = linearstep(
                    Mask - DispWidth,
                    Mask + DispWidth,
                    // Remap the pattern in preparation for comparing with the Mask value.
                    // The Mask is used to shift the ramp pattern up/down sufficiently to
                    // produce the desired Mask-edgeWidth, Mask+edgeWidth transition.
                    this_rampPattern + mix(
                                        -1.0000001-LowerCutoff - DispWidth,
                                        2.0-UpperCutoff + DispWidth,
                                        Mask
                                        )
                    );
    }

    // Pre-multiply by this mask.
    this_coverV *= dispMask;
    this_deltaP *= dispMask;

    // Note: coverV is not composited. It is only communicated
    // with the immediately overlying material layer.
    Material_Output_Params.coverV = this_coverV;

    // Displacement compositing.
    // Note: displacement is NOT Porter-Duff OVER operation composited.
    Material_Output_Params.deltaP = Material_Input_Params.deltaP
                                    + mix(
                                        this_deltaP,
                                        this_coverV,
                                        Material_Input_Params.thickness
                                        );

    // Thickness accumulates through all the layers, since layer displacements all accumulate.
    // Any overlying layer's thickness will apply to all layers below it, so always pass on the
    // largest thickness value.
    Material_Output_Params.thickness = max( Material_Input_Params.thickness, Thickness*dispMask );

    // Composite the dispMask.
    Material_Output_Params.dispMask = Material_Input_Params.dispMask
                                    + dispMask*( 1.0 - Material_Input_Params.dispMask );

    //
    // Bxdf shader parameters start here.
    // Note: Gain = 1.0, and Color = Gain*Color. This eliminates false
    // colors resulting from interpolating these parameters separately.
    //
    // Porter-Duff pre-multiplied alpha(mask) compositing OVER operation.
    //  Out = In over Ui:
    //  Out =   In*In_Mask*1 + Ui*Ui_Mask*(1 - In_Mask)
    //  Out_Mask = In_Mask*1 +    Ui_Mask*(1 - In_Mask)
    //
    // Composited output mask defines where the input material and this material exist.
    Material_Output_Params.bxdfMask = Material_Input_Params.bxdfMask
                                    + bxdfMask*( 1.0 - Material_Input_Params.bxdfMask );

    PARAM_OVER( Material_Output_Params, Material_Input_Params, , BumpPercent, bxdfMask );
    PARAM_OVER( Material_Output_Params, Material_Input_Params, global, ShadowColor, bxdfMask );
    PARAM_OVER( Material_Output_Params, Material_Input_Params, global, ShadingNormal, bxdfMask );

    // This material's globalUseShadingNormal value is 0 if its globalShadingNormal is not connected.
    float  useShadingNormal = isconnected( globalShadingNormal ) ? globalUseShadingNormal : 0.0;
    Material_Output_Params.globalUseShadingNormal = Material_Input_Params.globalUseShadingNormal
                            + useShadingNormal*bxdfMask*( 1.0 - Material_Input_Params.bxdfMask );

    // clearcoat
    if( clearcoatEnable == 1 )
    {
        Material_Output_Params.clearcoatEdgeCG = Material_Input_Params.clearcoatEdgeCG
                + ( clearcoatGain*clearcoatEdgeColor*bxdfMask )*( 1.0 - Material_Input_Params.bxdfMask );

        Material_Output_Params.clearcoatFaceCG = Material_Input_Params.clearcoatFaceCG
                + ( clearcoatGain*clearcoatFaceColor*bxdfMask )*( 1.0 - Material_Input_Params.bxdfMask );

        Material_Output_Params.clearcoatRefractionCI = Material_Input_Params.clearcoatRefractionCI
                + ( clearcoatRefractionIndex*clearcoatRefractionColor*bxdfMask )*( 1.0 - Material_Input_Params.bxdfMask );

        PARAM_OVER( Material_Output_Params, Material_Input_Params, clearcoat, FresnelExponent, bxdfMask );
        PARAM_OVER( Material_Output_Params, Material_Input_Params, clearcoat, LayerThickness, bxdfMask );
        PARAM_OVER( Material_Output_Params, Material_Input_Params, clearcoat, LayerColor, bxdfMask );
        PARAM_OVER( Material_Output_Params, Material_Input_Params, clearcoat, Roughness, bxdfMask );
        PARAM_OVER( Material_Output_Params, Material_Input_Params, clearcoat, Anisotropy, bxdfMask );
        PARAM_OVER( Material_Output_Params, Material_Input_Params, clearcoat, ShadingTangent, bxdfMask );
        PARAM_OVER( Material_Output_Params, Material_Input_Params, clearcoat, ShadingNormal, bxdfMask );

        float  useShadingTangent = isconnected( clearcoatShadingTangent ) ? 1.0 : 0.0;
        Material_Output_Params.clearcoatUseShadingTangent = Material_Input_Params.clearcoatUseShadingTangent
                                + useShadingTangent*bxdfMask*( 1.0 - Material_Input_Params.bxdfMask );

        float  useShadingNormal = isconnected( clearcoatShadingNormal ) ? clearcoatUseShadingNormal : 0.0;
        Material_Output_Params.clearcoatUseShadingNormal = Material_Input_Params.clearcoatUseShadingNormal
                                + useShadingNormal*bxdfMask*( 1.0 - Material_Input_Params.bxdfMask );
    }
    else
    {
        CLEARCOAT_COPY( Material_Output_Params, Material_Input_Params, clearcoat );
    }

    // specPrimary
    if( specPrimaryEnable == 1 )
    {
        Material_Output_Params.specPrimaryEdgeCG = Material_Input_Params.specPrimaryEdgeCG
                + ( specPrimaryGain*specPrimaryEdgeColor*bxdfMask )*( 1.0 - Material_Input_Params.bxdfMask );

        Material_Output_Params.specPrimaryFaceCG = Material_Input_Params.specPrimaryFaceCG
                + ( specPrimaryGain*specPrimaryFaceColor*bxdfMask )*( 1.0 - Material_Input_Params.bxdfMask );

        Material_Output_Params.specPrimaryRefractionCI = Material_Input_Params.specPrimaryRefractionCI
                + ( specPrimaryRefractionIndex*specPrimaryRefractionColor*bxdfMask )*( 1.0 - Material_Input_Params.bxdfMask );

        Material_Output_Params.specPrimaryExtinctionCC = Material_Input_Params.specPrimaryExtinctionCC
                + ( specPrimaryExtinctionCoeff*specPrimaryExtinctionColor*bxdfMask )*( 1.0 - Material_Input_Params.bxdfMask );

        PARAM_OVER( Material_Output_Params, Material_Input_Params, specPrimary, FresnelExponent, bxdfMask );
        PARAM_OVER( Material_Output_Params, Material_Input_Params, specPrimary, Roughness, bxdfMask );
        PARAM_OVER( Material_Output_Params, Material_Input_Params, specPrimary, Anisotropy, bxdfMask );
        PARAM_OVER( Material_Output_Params, Material_Input_Params, specPrimary, ShadingTangent, bxdfMask );
        PARAM_OVER( Material_Output_Params, Material_Input_Params, specPrimary, ShadingNormal, bxdfMask );

        float  useShadingTangent = isconnected( specPrimaryShadingTangent ) ? 1.0 : 0.0;
        Material_Output_Params.specPrimaryUseShadingTangent = Material_Input_Params.specPrimaryUseShadingTangent
                                + useShadingTangent*bxdfMask*( 1.0 - Material_Input_Params.bxdfMask );

        float  useShadingNormal = isconnected( specPrimaryShadingNormal ) ? specPrimaryUseShadingNormal : 0.0;
        Material_Output_Params.specPrimaryUseShadingNormal = Material_Input_Params.specPrimaryUseShadingNormal
                                + useShadingNormal*bxdfMask*( 1.0 - Material_Input_Params.bxdfMask );
    }
    else
    {
        SPECULAR_COPY( Material_Output_Params, Material_Input_Params, specPrimary );
    }

    // specSecondary
    if( specSecondaryEnable == 1 )
    {
        Material_Output_Params.specSecondaryEdgeCG = Material_Input_Params.specSecondaryEdgeCG
                + ( specSecondaryGain*specSecondaryEdgeColor*bxdfMask )*( 1.0 - Material_Input_Params.bxdfMask );

        Material_Output_Params.specSecondaryFaceCG = Material_Input_Params.specSecondaryFaceCG
                + ( specSecondaryGain*specSecondaryFaceColor*bxdfMask )*( 1.0 - Material_Input_Params.bxdfMask );

        Material_Output_Params.specSecondaryRefractionCI = Material_Input_Params.specSecondaryRefractionCI
                + ( specSecondaryRefractionIndex*specSecondaryRefractionColor*bxdfMask )*( 1.0 - Material_Input_Params.bxdfMask );

        Material_Output_Params.specSecondaryExtinctionCC = Material_Input_Params.specSecondaryExtinctionCC
                + ( specSecondaryExtinctionCoeff*specSecondaryExtinctionColor*bxdfMask )*( 1.0 - Material_Input_Params.bxdfMask );

        PARAM_OVER( Material_Output_Params, Material_Input_Params, specSecondary, FresnelExponent, bxdfMask );
        PARAM_OVER( Material_Output_Params, Material_Input_Params, specSecondary, Roughness, bxdfMask );
        PARAM_OVER( Material_Output_Params, Material_Input_Params, specSecondary, Anisotropy, bxdfMask );
        PARAM_OVER( Material_Output_Params, Material_Input_Params, specSecondary, ShadingTangent, bxdfMask );
        PARAM_OVER( Material_Output_Params, Material_Input_Params, specSecondary, ShadingNormal, bxdfMask );

        float  useShadingTangent = isconnected( specSecondaryShadingTangent ) ? 1.0 : 0.0;
        Material_Output_Params.specSecondaryUseShadingTangent = Material_Input_Params.specSecondaryUseShadingTangent
                                + useShadingTangent*bxdfMask*( 1.0 - Material_Input_Params.bxdfMask );

        float  useShadingNormal = isconnected( specSecondaryShadingNormal ) ? specSecondaryUseShadingNormal : 0.0;
        Material_Output_Params.specSecondaryUseShadingNormal = Material_Input_Params.specSecondaryUseShadingNormal
                                + useShadingNormal*bxdfMask*( 1.0 - Material_Input_Params.bxdfMask );
    }
    else
    {
        SPECULAR_COPY( Material_Output_Params, Material_Input_Params, specSecondary );
    }

    // iridescence
    if( iridescenceEnable == 1 )
    {
        PARAM_OVER( Material_Output_Params, Material_Input_Params, iridescence, Gain, bxdfMask );
        PARAM_OVER( Material_Output_Params, Material_Input_Params, iridescence, FaceColor, bxdfMask );
        PARAM_OVER( Material_Output_Params, Material_Input_Params, iridescence, EdgeColor, bxdfMask );
        PARAM_OVER( Material_Output_Params, Material_Input_Params, iridescence, Exponent, bxdfMask );
        PARAM_OVER( Material_Output_Params, Material_Input_Params, iridescence, Repetitions, bxdfMask );
        PARAM_OVER( Material_Output_Params, Material_Input_Params, iridescence, Thickness, bxdfMask );
        PARAM_OVER( Material_Output_Params, Material_Input_Params, iridescence, Roughness, bxdfMask );
        PARAM_OVER( Material_Output_Params, Material_Input_Params, iridescence, Anisotropy, bxdfMask );
        PARAM_OVER( Material_Output_Params, Material_Input_Params, iridescence, ShadingTangent, bxdfMask );

        float  useShadingTangent = isconnected( iridescenceShadingTangent ) ? 1.0 : 0.0;
        Material_Output_Params.iridescenceUseShadingTangent = Material_Input_Params.iridescenceUseShadingTangent
                                + useShadingTangent*bxdfMask*( 1.0 - Material_Input_Params.bxdfMask );
    }
    else
    {
        IRIDESCENCE_COPY( Material_Output_Params, Material_Input_Params, iridescence );
    }

    // fuzz
    if( fuzzEnable == 1 )
    {
        Material_Output_Params.fuzzCG = Material_Input_Params.fuzzCG
                + ( fuzzGain*fuzzColor*bxdfMask )*( 1.0 - Material_Input_Params.bxdfMask );

        PARAM_OVER( Material_Output_Params, Material_Input_Params, fuzz, ConeAngle, bxdfMask );
        PARAM_OVER( Material_Output_Params, Material_Input_Params, fuzz, ShadingNormal, bxdfMask );

        float  useShadingNormal = isconnected( fuzzShadingNormal ) ? fuzzUseShadingNormal : 0.0;
        Material_Output_Params.fuzzUseShadingNormal = Material_Input_Params.fuzzUseShadingNormal
                                + useShadingNormal*bxdfMask*( 1.0 - Material_Input_Params.bxdfMask );
    }
    else
    {
        FUZZ_COPY( Material_Output_Params, Material_Input_Params, fuzz );
    }

    // diffuse
    if( diffuseEnable == 1 )
    {
        Material_Output_Params.diffuseCG = Material_Input_Params.diffuseCG
                + ( diffuseGain*diffuseColor*bxdfMask )*( 1.0 - Material_Input_Params.bxdfMask );

        Material_Output_Params.diffuseBackfaceCG = Material_Input_Params.diffuseBackfaceCG
                + ( diffuseBackfaceGain*diffuseBackfaceColor*bxdfMask )*( 1.0 - Material_Input_Params.bxdfMask );

        Material_Output_Params.diffuseTransmitCG = Material_Input_Params.diffuseTransmitCG
                + ( diffuseTransmitGain*diffuseTransmitColor*bxdfMask )*( 1.0 - Material_Input_Params.bxdfMask );

        PARAM_OVER( Material_Output_Params, Material_Input_Params, diffuse, Roughness, bxdfMask );
        PARAM_OVER( Material_Output_Params, Material_Input_Params, diffuse, FalloffExponent, bxdfMask );
        PARAM_OVER( Material_Output_Params, Material_Input_Params, diffuse, ShadingNormal, bxdfMask );

        float  useShadingNormal = isconnected( diffuseShadingNormal ) ? diffuseUseShadingNormal : 0.0;
        Material_Output_Params.diffuseUseShadingNormal = Material_Input_Params.diffuseUseShadingNormal
                                + useShadingNormal*bxdfMask*( 1.0 - Material_Input_Params.bxdfMask );
    }
    else
    {
        DIFFUSE_COPY( Material_Output_Params, Material_Input_Params, diffuse );
    }

    // scatter
    if( scatterEnable == 1 )
    {
        Material_Output_Params.scatterCG = Material_Input_Params.scatterCG
                + ( scatterGain*scatterColor*bxdfMask )*( 1.0 - Material_Input_Params.bxdfMask );

        Material_Output_Params.scatterBacksideCG = Material_Input_Params.scatterBacksideCG
                + ( scatterBacksideGain*scatterBacksideTint*bxdfMask )*( 1.0 - Material_Input_Params.bxdfMask );

        PARAM_OVER( Material_Output_Params, Material_Input_Params, scatter, PathLength, bxdfMask );
        PARAM_OVER( Material_Output_Params, Material_Input_Params, scatter, PathColor, bxdfMask );
        PARAM_OVER( Material_Output_Params, Material_Input_Params, scatter, Direction, bxdfMask );
        PARAM_OVER( Material_Output_Params, Material_Input_Params, scatter, Roughness, bxdfMask );
        PARAM_OVER( Material_Output_Params, Material_Input_Params, scatter, RefractionIndex, bxdfMask );
    }
    else
    {
        SCATTER_COPY( Material_Output_Params, Material_Input_Params, scatter );
    }

    // subsurface
    if( subsurfaceEnable == 1 )
    {
        Material_Output_Params.subsurfaceCG = Material_Input_Params.subsurfaceCG
                + ( subsurfaceGain*subsurfaceColor*bxdfMask )*( 1.0 - Material_Input_Params.bxdfMask );

        Material_Output_Params.subsurfaceShortCG = Material_Input_Params.subsurfaceShortCG
                + ( subsurfaceShortGain*subsurfaceShortColor*bxdfMask )*( 1.0 - Material_Input_Params.bxdfMask );

        Material_Output_Params.subsurfaceLongCG = Material_Input_Params.subsurfaceLongCG
                + ( subsurfaceLongGain*subsurfaceLongColor*bxdfMask )*( 1.0 - Material_Input_Params.bxdfMask );

        PARAM_OVER( Material_Output_Params, Material_Input_Params, subsurface, PathLength, bxdfMask );
        PARAM_OVER( Material_Output_Params, Material_Input_Params, subsurface, PathColor, bxdfMask );
        PARAM_OVER( Material_Output_Params, Material_Input_Params, subsurface, PostTint, bxdfMask );
        PARAM_OVER( Material_Output_Params, Material_Input_Params, subsurface, TransmitGain, bxdfMask );
        PARAM_OVER( Material_Output_Params, Material_Input_Params, subsurface, ShortLength, bxdfMask );
        PARAM_OVER( Material_Output_Params, Material_Input_Params, subsurface, LongLength, bxdfMask );
        PARAM_OVER( Material_Output_Params, Material_Input_Params, subsurface, Directionality, bxdfMask );
        PARAM_OVER( Material_Output_Params, Material_Input_Params, subsurface, DiffuseBlend, bxdfMask );
        PARAM_OVER( Material_Output_Params, Material_Input_Params, subsurface, Bleed, bxdfMask );
    }
    else
    {
        SUBSURFACE_COPY( Material_Output_Params, Material_Input_Params, subsurface );
    }

    // scatter & subsurface
    if( scatterEnable == 1 || subsurfaceEnable == 1 )
    {
        PARAM_OVER( Material_Output_Params, Material_Input_Params, ss, IlluminationTint, bxdfMask );
        PARAM_OVER( Material_Output_Params, Material_Input_Params, ss, Roughness, bxdfMask );
    }
    else
    {
        Material_Output_Params.ssIlluminationTint = Material_Input_Params.ssIlluminationTint;
        Material_Output_Params.ssRoughness = Material_Input_Params.ssRoughness;
    }

    // glass
    if( glassEnable == 1 )
    {
        Material_Output_Params.glassRefractionCG = Material_Input_Params.glassRefractionCG
                + ( glassRefractionGain*glassRefractionColor*bxdfMask )*( 1.0 - Material_Input_Params.bxdfMask );

        PARAM_OVER( Material_Output_Params, Material_Input_Params, glass, ReflectionGain, bxdfMask );
        PARAM_OVER( Material_Output_Params, Material_Input_Params, glass, RefractionIndex, bxdfMask );
        PARAM_OVER( Material_Output_Params, Material_Input_Params, glass, Roughness, bxdfMask );
        PARAM_OVER( Material_Output_Params, Material_Input_Params, glass, Anisotropy, bxdfMask );
        PARAM_OVER( Material_Output_Params, Material_Input_Params, glass, ShadingTangent, bxdfMask );

        float  useShadingTangent = isconnected( glassShadingTangent ) ? 1.0 : 0.0;
        Material_Output_Params.glassUseShadingTangent = Material_Input_Params.glassUseShadingTangent
                                + useShadingTangent*bxdfMask*( 1.0 - Material_Input_Params.bxdfMask );
    }
    else
    {
        GLASS_COPY( Material_Output_Params, Material_Input_Params, glass );
    }

    // glow
    if( glowEnable == 1 )
    {
        Material_Output_Params.glowCG = Material_Input_Params.glowCG
                + ( glowGain*glowColor*bxdfMask )*( 1.0 - Material_Input_Params.bxdfMask );
    }
    else
    {
        GLOW_COPY( Material_Output_Params, Material_Input_Params, glow );
    }

    }
}
